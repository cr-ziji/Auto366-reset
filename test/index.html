<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>封闭Shadow DOM的访问方法</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 40px;
            padding: 20px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #7f8c8d;
            font-size: 1.2rem;
        }
        
        .content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        @media (max-width: 768px) {
            .content {
                grid-template-columns: 1fr;
            }
        }
        
        .card {
            background: white;
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .card h2 {
            color: #3498db;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #f0f0f0;
        }
        
        .demo-area {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }
        
        .shadow-host {
            padding: 15px;
            margin: 15px 0;
            background: #e8f4fc;
            border-radius: 5px;
            border: 1px dashed #3498db;
        }
        
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            margin: 5px 0;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #2980b9;
        }
        
        pre {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-size: 0.9rem;
        }
        
        .method {
            margin-bottom: 25px;
        }
        
        .result {
            padding: 12px;
            background: #f0f4f8;
            border-radius: 5px;
            margin: 10px 0;
            font-family: monospace;
            min-height: 40px;
        }
        
        .highlight {
            color: #e74c3c;
            font-weight: bold;
        }
        
        .explanation {
            color: #7f8c8d;
            font-style: italic;
            margin: 10px 0;
        }
        
        .events {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>封闭Shadow DOM的内部与外部通信</h1>
            <p class="subtitle">探索访问封闭Shadow DOM（mode: 'closed'）的几种技术</p>
        </header>
        
        <div class="content">
            <div class="card">
                <h2>方法一：通过事件进行通信</h2>
                <div class="method">
                    <p class="explanation">从Shadow DOM内部触发自定义事件，外部监听并响应</p>
                    
                    <div class="demo-area">
                        <div id="event-host" class="shadow-host">
                            <!-- Shadow DOM将附加到这里 -->
                        </div>
                        
                        <div class="events">
                            <button id="listen-btn">开始监听内部事件</button>
                            <button id="stop-listening-btn">停止监听</button>
                        </div>
                        
                        <div class="result" id="event-result">等待事件触发...</div>
                    </div>
                    
                    <pre><code>// 内部代码
const event = new CustomEvent('internal-event', {
  detail: { message: '来自内部的消息', data: 42 },
  bubbles: true,
  composed: true  // 允许事件穿过Shadow边界
});
this.dispatchEvent(event);

// 外部代码
hostElement.addEventListener('internal-event', (e) => {
  console.log('收到内部事件:', e.detail);
});</code></pre>
                </div>
                
                <h2>方法二：通过引用传递</h2>
                <div class="method">
                    <p class="explanation">在创建Shadow DOM时，将外部对象的引用传递给内部</p>
                    
                    <div class="demo-area">
                        <div id="reference-host" class="shadow-host">
                            <!-- Shadow DOM将附加到这里 -->
                        </div>
                        
                        <button id="reference-btn">通过引用调用内部方法</button>
                        
                        <div class="result" id="reference-result">等待操作...</div>
                    </div>
                    
                    <pre><code>// 外部代码
const externalObj = {
  showMessage: (msg) => {
    alert('来自外部的消息: ' + msg);
  }
};

// 创建Shadow DOM时传递引用
const shadow = element.attachShadow({ mode: 'closed' });
shadow.externalRef = externalObj;

// 内部代码
if (this.externalRef) {
  this.externalRef.showMessage('Hello from Shadow DOM!');
}</code></pre>
                </div>
            </div>
            
            <div class="card">
                <h2>方法三：使用属性/方法注入</h2>
                <div class="method">
                    <p class="explanation">在宿主元素上定义方法或属性，供内部代码调用</p>
                    
                    <div class="demo-area">
                        <div id="injection-host" class="shadow-host">
                            <!-- Shadow DOM将附加到这里 -->
                        </div>
                        
                        <button id="injection-btn">调用宿主元素上的方法</button>
                        
                        <div class="result" id="injection-result">等待操作...</div>
                    </div>
                    
                    <pre><code>// 外部代码
const hostElement = document.getElementById('host');
hostElement.externalMethod = function(data) {
  console.log('从内部调用:', data);
  return '外部方法响应';
};

// 内部代码
const host = this.getRootNode().host;
if (host && host.externalMethod) {
  const response = host.externalMethod('内部数据');
  console.log(response);
}</code></pre>
                </div>
                
                <h2>方法四：使用消息通道</h2>
                <div class="method">
                    <p class="explanation">使用MessageChannel或postMessage建立通信通道</p>
                    
                    <div class="demo-area">
                        <div id="message-host" class="shadow-host">
                            <!-- Shadow DOM将附加到这里 -->
                        </div>
                        
                        <div class="events">
                            <button id="message-send">发送消息到内部</button>
                            <button id="message-request">请求内部数据</button>
                        </div>
                        
                        <div class="result" id="message-result">等待消息...</div>
                    </div>
                    
                    <pre><code>// 外部代码
const channel = new MessageChannel();
channel.port1.onmessage = (event) => {
  console.log('来自内部的消息:', event.data);
};

// 将端口传递给Shadow DOM
shadowRoot.messagePort = channel.port2;

// 内部代码
if (this.messagePort) {
  this.messagePort.postMessage({
    type: 'message',
    content: '来自Shadow DOM的消息'
  });
}</code></pre>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 方法1：通过事件进行通信
        (function() {
            const host = document.getElementById('event-host');
            const shadow = host.attachShadow({ mode: 'closed' });
            const resultDisplay = document.getElementById('event-result');
            
            // 创建内部内容
            const innerDiv = document.createElement('div');
            innerDiv.innerHTML = `
                <style>
                    button { 
                        background: #e74c3c; 
                        margin: 5px;
                    }
                    button:hover { 
                        background: #c0392b; 
                    }
                </style>
                <p>这是封闭的Shadow DOM内部</p>
                <button id="internal-btn">触发内部事件</button>
                <button id="internal-data-btn">发送数据事件</button>
            `;
            
            shadow.appendChild(innerDiv);
            
            // 内部事件处理
            innerDiv.querySelector('#internal-btn').addEventListener('click', () => {
                const event = new CustomEvent('internal-event', {
                    detail: { message: 'Hello from Shadow DOM!', time: new Date().toLocaleTimeString() },
                    bubbles: true,
                    composed: true
                });
                host.dispatchEvent(event);
            });
            
            // 内部事件处理
            innerDiv.querySelector('#internal-btn').addEventListener('click', function(event){
                // console.log(document.body.outerHTML)
            });
            
            innerDiv.querySelector('#internal-data-btn').addEventListener('click', () => {
                const event = new CustomEvent('internal-data', {
                    detail: { 
                        data: [1, 2, 3, 4, 5],
                        value: Math.random().toFixed(2)
                    },
                    bubbles: true,
                    composed: true
                });
                host.dispatchEvent(event);
            });
            
            // 外部事件监听
            let listening = false;
            
            document.getElementById('listen-btn').addEventListener('click', () => {
                if (!listening) {
                    host.addEventListener('internal-event', handleInternalEvent);
                    host.addEventListener('internal-data', handleInternalData);
                    resultDisplay.textContent = '开始监听内部事件...';
                    listening = true;
                }
            });
            
            document.getElementById('stop-listening-btn').addEventListener('click', () => {
                if (listening) {
                    host.removeEventListener('internal-event', handleInternalEvent);
                    host.removeEventListener('internal-data', handleInternalData);
                    resultDisplay.textContent = '已停止监听内部事件';
                    listening = false;
                }
            });
            
            function handleInternalEvent(e) {
                resultDisplay.innerHTML = `收到内部事件: <span class="highlight">${e.detail.message}</span> (${e.detail.time})`;
            }
            
            function handleInternalData(e) {
                resultDisplay.innerHTML = `收到数据事件: 值=<span class="highlight">${e.detail.value}</span>, 数据=[${e.detail.data.join(', ')}]`;
            }
        })();
        
        // 方法2：通过引用传递
        (function() {
            const host = document.getElementById('reference-host');
            const resultDisplay = document.getElementById('reference-result');
            
            // 创建外部对象
            const externalObj = {
                showMessage: function(msg) {
                    resultDisplay.innerHTML = `<span class="highlight">${msg}</span>`;
                },
                getData: function() {
                    return { externalData: [10, 20, 30], timestamp: new Date().toLocaleTimeString() };
                }
            };
            
            // 创建Shadow DOM并传递引用
            const shadow = host.attachShadow({ mode: 'closed' });
            shadow.externalRef = externalObj;
            
            // 创建内部内容
            const innerDiv = document.createElement('div');
            innerDiv.innerHTML = `
                <style>
                    button { 
                        background: #9b59b6; 
                        margin: 5px;
                    }
                    button:hover { 
                        background: #8e44ad; 
                    }
                </style>
                <p>这是封闭的Shadow DOM内部</p>
                <p>已注入外部引用: <span id="ref-status">${shadow.externalRef ? '可用' : '不可用'}</span></p>
            `;
            
            shadow.appendChild(innerDiv);
            
            // 存储内部方法供外部调用
            shadow.internalMethod = function() {
                return { 
                    message: "来自内部方法的响应", 
                    random: Math.random().toFixed(4),
                    elements: innerDiv.querySelectorAll('*').length
                };
            };
            
            // 外部按钮调用内部方法
            document.getElementById('reference-btn').addEventListener('click', () => {
                if (shadow.internalMethod) {
                    const result = shadow.internalMethod();
                    resultDisplay.innerHTML = `内部方法响应: <span class="highlight">${result.message}</span><br>
                                              随机值: ${result.random}<br>
                                              元素数量: ${result.elements}`;
                } else {
                    resultDisplay.textContent = "无法访问内部方法";
                }
            });
        })();
        
        // 方法3：使用属性/方法注入
        (function() {
            const host = document.getElementById('injection-host');
            const resultDisplay = document.getElementById('injection-result');
            
            // 在宿主元素上定义外部方法
            host.externalMethod = function(data) {
                resultDisplay.innerHTML = `宿主方法被调用，数据: <span class="highlight">${JSON.stringify(data)}</span>`;
                return { status: 'success', received: data, respondedAt: new Date().toLocaleTimeString() };
            };
            
            // 创建Shadow DOM
            const shadow = host.attachShadow({ mode: 'closed' });
            
            // 创建内部内容
            const innerDiv = document.createElement('div');
            innerDiv.innerHTML = `
                <style>
                    button { 
                        background: #2ecc71; 
                        margin: 5px;
                    }
                    button:hover { 
                        background: #27ae60; 
                    }
                </style>
                <p>这是封闭的Shadow DOM内部</p>
                <button id="call-external">调用外部方法</button>
                <div id="internal-result"></div>
            `;
            
            shadow.appendChild(innerDiv);
            
            // 内部按钮点击处理
            innerDiv.querySelector('#call-external').addEventListener('click', () => {
                // 获取宿主元素
                const hostElement = innerDiv.getRootNode().host;
                
                if (hostElement && hostElement.externalMethod) {
                    const response = hostElement.externalMethod({
                        from: 'Shadow DOM',
                        value: Math.random().toFixed(4),
                        time: new Date().toLocaleTimeString()
                    });
                    
                    innerDiv.querySelector('#internal-result').innerHTML = 
                        `外部响应: <strong>${response.status}</strong> at ${response.respondedAt}`;
                } else {
                    innerDiv.querySelector('#internal-result').textContent = 
                        "无法访问外部方法";
                }
            });
            
            // 外部按钮点击处理
            document.getElementById('injection-btn').addEventListener('click', () => {
                if (host.callInternalMethod) {
                    const result = host.callInternalMethod();
                    resultDisplay.innerHTML = `内部方法调用结果: <span class="highlight">${result}</span>`;
                } else {
                    resultDisplay.textContent = "没有可用的内部方法";
                }
            });
            
            // 在Shadow DOM中定义内部方法供外部调用
            shadow.internalMethod = function() {
                return `内部方法被调用 at ${new Date().toLocaleTimeString()}`;
            };
            
            // 使内部方法在宿主元素上可用
            host.callInternalMethod = function() {
                return shadow.internalMethod ? shadow.internalMethod() : "方法不可用";
            };
        })();
        
        // 方法4：使用消息通道
        (function() {
            const host = document.getElementById('message-host');
            const resultDisplay = document.getElementById('message-result');
            
            // 创建消息通道
            const channel = new MessageChannel();
            
            // 设置外部端口监听
            channel.port1.onmessage = (event) => {
                if (event.data.type === 'response') {
                    resultDisplay.innerHTML = `收到内部响应: <span class="highlight">${event.data.content}</span>`;
                } else {
                    resultDisplay.innerHTML = `收到内部消息: <span class="highlight">${JSON.stringify(event.data)}</span>`;
                }
            };
            
            // 创建Shadow DOM并传递消息端口
            const shadow = host.attachShadow({ mode: 'closed' });
            shadow.messagePort = channel.port2;
            
            // 创建内部内容
            const innerDiv = document.createElement('div');
            innerDiv.innerHTML = `
                <style>
                    button { 
                        background: #f39c12; 
                        margin: 5px;
                    }
                    button:hover { 
                        background: #e67e22; 
                    }
                </style>
                <p>这是封闭的Shadow DOM内部</p>
                <div id="message-display">等待消息...</div>
                <button id="internal-msg-btn">发送消息到外部</button>
            `;
            
            shadow.appendChild(innerDiv);
            
            const messageDisplay = innerDiv.querySelector('#message-display');
            
            // 启动内部端口
            if (shadow.messagePort) {
                shadow.messagePort.start();
                
                // 内部消息监听
                shadow.messagePort.onmessage = (event) => {
                    if (event.data.type === 'request') {
                        messageDisplay.innerHTML = `收到外部请求: <strong>${event.data.content}</strong>`;
                        
                        // 发送响应
                        shadow.messagePort.postMessage({
                            type: 'response',
                            content: `内部数据: ${Math.random().toFixed(4)} at ${new Date().toLocaleTimeString()}`
                        });
                    } else {
                        messageDisplay.innerHTML = `收到外部消息: <strong>${JSON.stringify(event.data)}</strong>`;
                    }
                };
                
                // 内部按钮点击处理
                innerDiv.querySelector('#internal-msg-btn').addEventListener('click', () => {
                    shadow.messagePort.postMessage({
                        type: 'message',
                        content: 'Hello from Shadow DOM!',
                        time: new Date().toLocaleTimeString()
                    });
                });
            }
            
            // 外部发送消息按钮
            document.getElementById('message-send').addEventListener('click', () => {
                channel.port1.postMessage({
                    type: 'message',
                    content: 'Hello from external!',
                    time: new Date().toLocaleTimeString()
                });
                
                resultDisplay.textContent = '消息已发送到内部...';
            });
            
            // 外部请求数据按钮
            document.getElementById('message-request').addEventListener('click', () => {
                channel.port1.postMessage({
                    type: 'request',
                    content: '请发送一些数据'
                });
                
                resultDisplay.textContent = '数据请求已发送...';
            });
        })();
    </script>
</body>
</html>